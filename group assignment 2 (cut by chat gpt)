lapply(c("readr", "reshape2", "ggplot2", "dplyr", "factoextra", "ggbiplot", "boot", "pls"), library, character.only = TRUE)

setwd("C:/Users/jtgb0/OneDrive/Ambiente de Trabalho/Int to DS/Assignment/Assignment 2")
gei <- read.csv2("Team_2_gei_data.csv")
db <- read.csv2("Team_2_db_data.csv")

###Cleaning the Data

gei <- gei[,-1]
db <- db[,-1]

variables <- c("DATE", "COUNTRY_NAME", "INDICATOR_NAME",
               "VALUE")

gei_subset <- gei[, variables]

#Build a df for each year 
gei_2017 <- data.frame(dcast(gei_subset[which(gei_subset$DATE ==
                                                "2017"), ], COUNTRY_NAME ~ INDICATOR_NAME), YEAR = "2017")
gei_2018 <- data.frame(dcast(gei_subset[which(gei_subset$DATE ==
                                                "2018"), ], COUNTRY_NAME ~ INDICATOR_NAME), YEAR = "2018")
gei_2019 <- data.frame(dcast(gei_subset[which(gei_subset$DATE ==
                                                "2019"), ], COUNTRY_NAME ~ INDICATOR_NAME), YEAR = "2019")
#Merge them
gei_cleaned <- rbind(gei_2017, gei_2018, gei_2019)

colnames(gei_cleaned)[1] <- "COUNTRY"
colnames(gei_cleaned)[4] <- "GEI_score"

#Change the variables to numeric
gei_cleaned[, 2:16] <- lapply(gei_cleaned[, 2:16], function(x) as.numeric(as.character(x)))

#Remove columns for DB score for 2015, 2010-2014
db_cleaned <- subset(db, select = -c(7, 8))

# Rename country, year and DB score columns
names(db_cleaned)[2] <- "COUNTRY"
names(db_cleaned)[5] <- "YEAR"
names(db_cleaned)[6] <- "DB_score"
##################################################################################

#1.1

db_gei_data <- merge(db_cleaned, gei_cleaned, by = c('COUNTRY', 'YEAR'))

#2.1

plot(db_gei_data$DB_score, db_gei_data$GEI_score,
     main = "Scatter Plot of DB Scores vs GEI Scores",
     xlab = "DB Scores",
     ylab = "GEI Scores",
     col = "blue", 
     pch = 19)
abline(lm(GEI_score ~ DB_score, data = db_gei_data), col = "red")


correlation <- cor(db_gei_data$DB_score, db_gei_data$GEI_score) 
print(correlation)

#2.2

plot(db_gei_data$DB_score, db_gei_data$Oppurtunity.startup,
     main = "Scatter Plot of DB Scores vs Oppurtunity Startup",
     xlab = "DB Scores",
     ylab = "GEI Scores",
     col = "blue", 
     pch = 19)
abline(lm(Oppurtunity.startup ~ DB_score, data = db_gei_data), col = "red")
correlation_Oppurtunity.startup <- cor(db_gei_data$DB_score, db_gei_data$Oppurtunity.startup) 
print(correlation_Oppurtunity.startup)


plot(db_gei_data$DB_score, db_gei_data$Competition,
     main = "Scatter Plot of DB Scores vs Competition",
     xlab = "DB Scores",
     ylab = "GEI Scores",
     col = "blue", 
     pch = 19)
abline(lm(Competition ~ DB_score, data = db_gei_data), col = "red")
correlation_competition <- cor(db_gei_data$DB_score, db_gei_data$Competition) 
print(correlation_competition)


plot(db_gei_data$DB_score, db_gei_data$Process.Innovation,
     main = "Scatter Plot of DB Scores vs Process Innovation",
     xlab = "DB Scores",
     ylab = "GEI Scores",
     col = "blue", 
     pch = 19)
abline(lm(Process.Innovation ~ DB_score, data = db_gei_data), col = "red")
correlation_Process.Innovation <- cor(db_gei_data$DB_score, db_gei_data$Process.Innovation) 
print(correlation_Process.Innovation)

#3.1

gei_indicators <- db_gei_data[, c(7,8,10:21)]

set.seed(123)

pca_results <- prcomp(gei_indicators, center = TRUE, scale = TRUE) 
summary(pca_results)


#3.2

source("permtestPCA.R")
permtestPCA(gei_indicators, nTests = 1000) 
summary(pca_results)

#3.3

#Kaiser rule and Scree Plot 
observed_eigenvalues <- pca_results$sdev^2 
print(observed_eigenvalues)

eigen_df <- data.frame(PC = 1:length(observed_eigenvalues), Eigenvalue = observed_eigenvalues)
ggplot(eigen_df, aes(x = PC, y = observed_eigenvalues)) +
  geom_point(color = "blue", size = 3) +
  geom_line(color = "blue") +
  geom_hline(yintercept = 1, color = "red", linetype = "dashed") +
  xlab("Principal Component") + 
  ylab("Eigenvalue") +
  ggtitle("Scree Plot") +
  theme_minimal(base_size = 15) +
  theme(panel.background = element_rect(fill = "white"))

#Scree plot & VAF
fviz_eig(pca_results, addlabels = TRUE, ylim = c(0, 70))

#3.4

fviz_pca_biplot(pca_results, label = "var", col.var = "black") + ggtitle("PCA Biplot for GEI Indicators")
print(pca_results$rotation)
##############################################################################################3
#3.5

##########CHATGPT

var_pc1 <- function(data, indices) {
  resampled_data <- data[indices, ]
  pca_resampled <- prcomp(resampled_data, scale. = TRUE)
  var_explained <- (pca_resampled$sdev^2) / sum(pca_resampled$sdev^2)
  return(var_explained[1])  
}

set.seed(123)
results_pc1 <- boot(gei_indicators, statistic = var_pc1, R = 1000)

boot.ci(results_pc1, type = "perc")

pc1_loadings <- abs(pca_results$rotation[, 1])

top_contributors <- sort(pc1_loadings, decreasing = TRUE)[1:14]  
top_contributors
############################################

##########CHATGPT

# Function to calculate variance explained by PC1
var_bootstrap <- function(data, indices) {
  resampled_data <- data[indices, ]
  pca_resampled <- prcomp(resampled_data, scale. = TRUE)
  var_explained <- pca_resampled$sdev^2 / sum(pca_resampled$sdev^2)
  return(var_explained[1])  # Return variance explained by PC1
}

# Bootstrap the variance explained by PC1
set.seed(123)
bootstrap_results <- boot(gei_indicators, statistic = var_bootstrap, R = 1000)

# Get 95% Confidence Interval for total variance explained by PC1
ci_pc1 <- boot.ci(bootstrap_results, type = "perc")
print(ci_pc1)

### Step 3: Identify GEI Variables Best Explained by PC1

# Extract loadings for PC1
loadings_pc1 <- pca_results$rotation[, 1]
print("Loadings for PC1:")
print(loadings_pc1)

# Function to bootstrap loadings of variables on PC1
loadings_bootstrap <- function(data, indices) {
  resampled_data <- data[indices, ]
  pca_resampled <- prcomp(resampled_data, scale. = TRUE)
  return(pca_resampled$rotation[, 1])  # Loadings for PC1
}

# Bootstrap to calculate confidence intervals for each variable's loading on PC1
set.seed(123)
bootstrap_loadings <- boot(gei_indicators, statistic = loadings_bootstrap, R = 1000)

# Calculate 95% confidence intervals for the loadings of each variable on PC1
for (i in 1:ncol(gei_indicators)) {
  ci_loading <- boot.ci(bootstrap_loadings, index = i, type = "perc")
  print(paste("95% CI for", colnames(gei_indicators)[i], "loading on PC1:"))
  print(ci_loading)
}


###########################################

##########TEACHER

my_boot_pca <- function(x, ind){
  res <- princomp(x[ind, ], cor = TRUE)
  return (res$sdev^2)
}
  # 2. Run bootstrap
fit.boot <- boot(data = gei_indicators, statistic = my_boot_pca, R = 1000)
  # 3. Store the bootstrapped statistic (here all eigenvalues)
eigs.boot <- fit.boot$t
  # Store the R x p matrix with eigenvalues
head (eigs.boot)
pca_results$sdev^2

par(mfrow = c(1,1), mar = c(5, 4, 4, 1) + 0.1)

# Histogram for the first eigenvalue from bootstrap results
hist(eigs.boot[, 1], 
     xlab = "Eigenvalue 1", 
     las = 1, 
     col = "blue", 
     main = "Bootstrap Confidence Interval", 
     breaks = 20, 
     border = "white")

perc.alpha <- quantile(eigs.boot[, 1], c(0.025, 0.975))
print(perc.alpha)


abline(v = perc.alpha, col = "green", lwd = 2)
abline(v = pca_results$sdev[1]^2, col = "red", lwd = 2)


### Variance Explained
# Calculate variance explained by the first two components
var.expl <- rowSums(eigs.boot[, 1:2]) / rowSums(eigs.boot)

# Histogram for variance explained
hist(var.expl, 
     xlab = "Variance Explained", 
     las = 1, 
     col = "blue", 
     main = "Bootstrap Confidence Interval", 
     breaks = 20, 
     border = "white")

# Calculate confidence interval for variance explained
perc.alpha_var <- quantile(var.expl, c(0.025, 0.975))
print(perc.alpha_var)

# Add vertical line for the variance explained confidence interval
abline(v = perc.alpha_var, col = "green", lwd = 2)


# 4.1

set.seed(123)

train_index <- sample(1:nrow(db_gei_data), 0.7 * nrow(db_gei_data))
train_set <- db_gei_data[train_index, ]
test_set <- db_gei_data[-train_index, ]

# 4.2 

benchmark_model <- lm(DB_score ~ ., data = train_set[, c(6,7,8,10:21)])  
summary(benchmark_model)

